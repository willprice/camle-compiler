% Created 2015-01-08 Thu 20:41
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\tolerance=1000
\date{\today}
\title{A Compiler for the CAMLE language}
\hypersetup{
 pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.4.1 (Org mode 8.3beta)}}
\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
\label{sec-1}
\subsection{Language choice}
\label{sec-1-1}
I had initially started the coursework using \verb~Java~ and
\verb~ANTLRv4~. Unfortunately \verb~ANTLRv4~ deprecated the use of abstract
syntax trees in favour of node listeners that run a procedure when a
certain node is created\footnote{\url{https://theantlrguy.atlassian.net/wiki/display/~admin/2012/12/08/Tree+rewriting+in+ANTLR+v4}}, this was a choice by
the author \emph{Terence Parr} to make the use of \verb~ANTLR~ easier for most
users (who aren't building compilers). I then decided I'd switch back
to \verb~ANTLRv3~ as was suggested. I implemented the lexer and parser, and
spent a while trying to create an IR tree from the AST in \verb~Java~, this
was a deeply unpleasant experience. After around 10 hours of battling
with the \verb~Java~ code I decided I would instead switch to a language
with pattern matching. I had read good things about \verb~Haskell~ for
compiler writing, and I was keen to get more experience with some of
the more advanced concepts in the language such as \verb~applicative functors~ and \verb~monads~.
\section{Parser Design}
\label{sec-2}
There are a variety of libraries for parser construction in \verb~Haskell~,
\href{https://www.haskell.org/alex/doc/html/}{\verb~alex~} and \href{https://www.haskell.org/happy/}{\verb~happy~} are a pair of libraries often used in conjunction
for lexical analysis and parser generatation, however since I had
already gone down the route of parser generation in \verb~Java~ I decided
that instead I would try a different style of parsing utilising
\emph{parser combinators}, \verb~parsec~ is one of the more well known libraries
to implement this idiom, and seemed to have reasonable documentation
so I chose this.


``In functional programming, a parser combinator is a higher-order
function that accepts several parsers as input and returns a new
parser as its output''\footnote{Parser Combinators - \url{http://en.wikipedia.org/wiki/Parser_combinators}}.

The \verb~parsec~ library is so well written, the source code acts as a
beautiful example reference. 
\section{Intermediate Representation Design}
\label{sec-3}
\subsection{Stack machine based design}
\label{sec-3-1}
At one stage I had considered generating instructions for a stack
machine from the AST, however I couldn't figure out how to allocate
registers for the variables that were stored via pushing to the stack.
\subsection{Three address code}
\label{sec-3-2}
\section{Backend Design}
\label{sec-4}
\section{Conclusion}
\label{sec-5}
% Emacs 24.4.1 (Org mode 8.3beta)
\end{document}